<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="cocoa_chen&#39;s blog">
  <meta name="keyword" content="objective-C, cocoa_chen, Swift">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      深入浅出GCD之dispatch_queue | cocoa_chen
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>cocoa_chen</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>深入浅出GCD之dispatch_queue</h2>
  <p class="post-date">2018-03-05</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>dispatch_queue</code>可以说是GCD编程中使用频率最高的API，本篇文章主要讲一下queue的相关用法和原理，关于queue的数据结构和常用定义见上篇文章。</p>
<h3 id="使用篇"><a href="#使用篇" class="headerlink" title="使用篇"></a>使用篇</h3><p>当我们处理耗时操作时，比如读取数据库、请求网络数据，为了避免这些耗时操作卡住UI,可将耗时任务放到子线程中，执行完成后再通知主线程更新UI，代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    //耗时操作</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">         //更新UI</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当多线程并发读写同一个资源时，为了保证资源读写的正确性，可以用Barrier Block解决该问题。<br>Dispatch Barrier会确保队列中先于Barrier Block提交的任务都完成后再执行它，并且执行时队列不会同步执行其它任务，等Barrier Block执行完成后再开始执行其他任务。代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建自定义并行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.gcdTest.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    //读操作</span><br><span class="line">    NSLog(@&quot;work1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    //barrier block,可用于写操作</span><br><span class="line">    //确保资源更新过程中不会有其他线程读取</span><br><span class="line">    NSLog(@&quot;work2&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    //读操作</span><br><span class="line">    NSLog(@&quot;work3&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里有个需要注意也是官方文档上提到的一点，如果我们调用dispatch_barrier_async时将Barrier blocks提交到一个global queue，barrier blocks执行效果与dispatch_async()一致；只有将Barrier blocks提交到使用DISPATCH_QUEUE_CONCURRENT属性创建的并行queue时它才会表现的如同预期。详细原因见后续源码分析。</p>
<h3 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h3><h3 id="dispatch-get-global-queue"><a href="#dispatch-get-global-queue" class="headerlink" title="dispatch_get_global_queue"></a>dispatch_get_global_queue</h3><p>dispatch_get_global_queue用于获取一个全局队列，先看一下它的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (flags &amp; ~(unsigned long)DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//封装调用_dispatch_get_root_queue函数</span><br><span class="line">	return _dispatch_get_root_queue(priority,</span><br><span class="line">			flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static inline dispatch_queue_t _dispatch_get_root_queue(long priority, bool overcommit)</span><br><span class="line">&#123;</span><br><span class="line">	if (overcommit) switch (priority) &#123;</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">		return &amp;_dispatch_root_queues[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">		return &amp;_dispatch_root_queues[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">		return &amp;_dispatch_root_queues[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">		return &amp;_dispatch_root_queues[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];</span><br><span class="line">	&#125;</span><br><span class="line">	switch (priority) &#123;</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">		return &amp;_dispatch_root_queues[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">		return &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">		return &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];</span><br><span class="line">	case DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">		return &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];</span><br><span class="line">	default:</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列优先级有八个，分别为低、默认、高、后台以及对应的overcommit。枚举定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY = 0,                //低优先级</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY,         //低优先级+overcommit</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY,                //默认优先级</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY,     //默认优先级+overcommit</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY,                   //高优先级</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY,        //高优先级+overcommit</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY,             //后台</span><br><span class="line">	DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY,  //后台+overcomit</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_get_root_queue</code>从_dispatch_root_queues结构体中获取对应优先级的队列。最后1bit为1的代表overcommit，带有overcommit标记的队列会在任务提交时新创建一个线程处理它。</p>
<p><code>_dispatch_root_queues</code>取出的<code>dispatch_queue_s</code>队列的do_ctxt字段表示queue的线程池，定义于<code>_dispatch_root_queue_contexts</code>结构体中，每个线程池的最大线程数限制是255。</p>
<p>下面看一下global queue的do_vtable结构体，它比较重要的是do_probe的调用函数<code>_dispatch_root_queue_probe</code>,这个函数在后续的分析中会用到。结构体定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//global queue的vtable定义</span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_root, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">	.do_kind = &quot;global-queue&quot;,</span><br><span class="line">	.do_dispose = _dispatch_pthread_root_queue_dispose, //销毁时调用</span><br><span class="line">	.do_probe = _dispatch_root_queue_probe,             //重要，唤醒队列时调用</span><br><span class="line">	.do_debug = dispatch_queue_debug,                   //debug回调</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-get-main-queue"><a href="#dispatch-get-main-queue" class="headerlink" title="dispatch_get_main_queue"></a>dispatch_get_main_queue</h3><p>该API的使用主要是在更新UI时获取<code>dispatch_get_main_queue()</code>并把任务提交到主队列中。它的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//宏定义，返回到是_dispatch_main_q</span><br><span class="line">#define dispatch_get_main_queue() \</span><br><span class="line">		DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q)</span><br><span class="line"></span><br><span class="line">//main_queue结构体定义</span><br><span class="line">struct dispatch_queue_s _dispatch_main_q = &#123;</span><br><span class="line">	.do_vtable = DISPATCH_VTABLE(queue),</span><br><span class="line">	.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],  //目标队列</span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,   </span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,  </span><br><span class="line">	.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">	.dq_label = &quot;com.apple.main-thread&quot;,   //队列名</span><br><span class="line">	.dq_running = 1,          </span><br><span class="line">	.dq_width = 1,            //最大并发数是1，串行队列</span><br><span class="line">	.dq_is_thread_bound = 1,  //线程绑定</span><br><span class="line">	.dq_serialnum = 1,        //序列号为1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main queue设置了并发数为1，即串行队列,并且将targetq指向com.apple.root.default-overcommit-priority队列。</p>
<h3 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h3><p><code>dispatch_queue_create</code>主要用来创建自定义的队列，流程图和源码如下：</p>
<p><img src="/images/gcd/WX20180402-115026.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) &#123;</span><br><span class="line">  //调用dispatch_queue_create_with_target</span><br><span class="line">	return dispatch_queue_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line">//dispatch_queue_create具体实现函数</span><br><span class="line">dispatch_queue_t dispatch_queue_create_with_target(const char *label,</span><br><span class="line">		dispatch_queue_attr_t attr, dispatch_queue_t tq) &#123;</span><br><span class="line">	dispatch_queue_t dq;</span><br><span class="line">   //申请内存空间</span><br><span class="line">	dq = _dispatch_alloc(DISPATCH_VTABLE(queue),</span><br><span class="line">			sizeof(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">  //初始化，设置自定义队列的基本属性，方法实现见下面</span><br><span class="line">	_dispatch_queue_init(dq);</span><br><span class="line">	if (label) &#123;</span><br><span class="line">	   //设置队列名</span><br><span class="line">		dq-&gt;dq_label = strdup(label);</span><br><span class="line">	&#125;</span><br><span class="line">	if (attr == DISPATCH_QUEUE_CONCURRENT) &#123;</span><br><span class="line">	   //并行队列设置dq_width为UINT32_MAX</span><br><span class="line">		dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">		if (!tq) &#123;</span><br><span class="line">		   //默认targetq，优先级为DISPATCH_QUEUE_PRIORITY_DEFAULT</span><br><span class="line">			tq = _dispatch_get_root_queue(0, false);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (!tq) &#123;</span><br><span class="line">		   //默认targetq，优先级为DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY</span><br><span class="line">			// Default target queue is overcommit!</span><br><span class="line">			tq = _dispatch_get_root_queue(0, true);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置自定义队列的目标队列，dq队列的任务会放到目标队列执行</span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	return _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br><span class="line">//队列初始化方法</span><br><span class="line">static inline void _dispatch_queue_init(dispatch_queue_t dq)</span><br><span class="line">&#123;</span><br><span class="line">	dq-&gt;do_next = (struct dispatch_queue_s *)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dq-&gt;dq_running = 0;      //队列当前运行时初始为0</span><br><span class="line">	dq-&gt;dq_width = 1;        //队列并发数默认为1，串行队列</span><br><span class="line">	dq-&gt;dq_serialnum = dispatch_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers,</span><br><span class="line">			relaxed);          //序列号,在_dispatch_queue_serial_numbers基础上原子性加1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码介绍了自定义队列是如何创建的，初始化时会将dq_width默认设置为1，即串行队列。如果外部设置attr为DISPATCH_QUEUE_CONCURRENT，将并发数改为UINT32_MAX；<br>自定义队列的serialnum是在_dispatch_queue_serial_numbers基础上原子性加一，即从12开始累加。1到11被保留的序列号定义如下（后续版本有改动，自定义序列从16开始累加）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// skip zero        //跳过0</span><br><span class="line">// 1 - main_q       //主队列</span><br><span class="line">// 2 - mgr_q        //管理队列</span><br><span class="line">// 3 - mgr_root_q   //管理队列的目标队列</span><br><span class="line">// 4,5,6,7,8,9,10,11 - global queues   //全局队列</span><br><span class="line">// we use &apos;xadd&apos; on Intel, so the initial value == next assigned</span><br><span class="line">unsigned long volatile _dispatch_queue_serial_numbers = 12;</span><br></pre></td></tr></table></figure>
<p>同时还会设置队列的target_queue，向队列提交的任务，都会被放到它的目标队列来执行。串行队列的target_queue是一个支持overcommit的全局队列，而全局队列的底层则是一个线程池。</p>
<p>借用一张队列的图片：</p>
<p><img src="/images/gcd/15211017152713.png" alt=""></p>
<h3 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h3><p><code>dispatch_async</code>用来异步执行任务，它的代码比较复杂，我们可以分成三个阶段来看，第一阶段是更新队列链表，第二部分是从队列取任务，第三部分则是执行任务。每个阶段都有一张流程图表示，觉得代码多的话可以直接看每个阶段对应的流程图。</p>
<p>首先看一下<code>dispatch_async</code>的入口函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_async(dispatch_queue_t dq, void (^work)(void)) &#123;</span><br><span class="line">	dispatch_async_f(dq, _dispatch_Block_copy(work),</span><br><span class="line">			_dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch_async封装调用了dispatch_async_f函数，先将block拷贝到堆上，避免block执行前被销毁，同时传入_dispatch_call_block_and_release来保证block执行后会执行Block_release。下面看一下dispatch_async_f的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;</span><br><span class="line">	dispatch_continuation_t dc;</span><br><span class="line">	if (dq-&gt;dq_width == 1) &#123;</span><br><span class="line">	   //如果是串行队列，执行dispatch_barrier_async_f，和当前函数的不同点在于</span><br><span class="line">	   //.do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT)</span><br><span class="line">		return dispatch_barrier_async_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	//将任务封装到dispatch_continuation_t结构体中</span><br><span class="line">	dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">	if (!dc) &#123;</span><br><span class="line">		return _dispatch_async_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	dc-&gt;do_vtable = (void *)DISPATCH_OBJ_ASYNC_BIT;  //将vtable设置为ASYNC标志位</span><br><span class="line">	dc-&gt;dc_func = func; </span><br><span class="line">	dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">	if (dq-&gt;do_targetq) &#123;</span><br><span class="line">	   //如果有do_targetq，将任务放到目标队列执行</span><br><span class="line">		return _dispatch_async_f2(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	//将任务压入队列(FIFO)</span><br><span class="line">	_dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分析一下_dispatch_queue_push，这是一个宏定义，展开后的调用栈如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_push</span><br><span class="line">└──_dispatch_trace_queue_push</span><br><span class="line">    └──_dispatch_queue_push</span><br></pre></td></tr></table></figure>
<p>看一下_dispatch_queue_push的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static inline void _dispatch_queue_push(dispatch_queue_t dq, dispatch_object_t _tail) &#123;</span><br><span class="line">	struct dispatch_object_s *tail = _tail._do;</span><br><span class="line">	//判断链表中是否已经存在节点，有的话返回YES,否则返回NO</span><br><span class="line">	if (!fastpath(_dispatch_queue_push_list2(dq, tail, tail))) &#123;</span><br><span class="line">	   //将任务放到链表头部</span><br><span class="line">		_dispatch_queue_push_slow(dq, tail);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//判断链表中是否已经存在节点</span><br><span class="line">static inline bool _dispatch_queue_push_list2(dispatch_queue_t dq, struct dispatch_object_s *head,</span><br><span class="line">		struct dispatch_object_s *tail) &#123;</span><br><span class="line">	struct dispatch_object_s *prev;</span><br><span class="line">	tail-&gt;do_next = NULL;</span><br><span class="line">	//将tail原子性赋值给dq-&gt;dq_items_tail，同时返回之前的值并赋给prev</span><br><span class="line">	prev = dispatch_atomic_xchg2o(dq, dq_items_tail, tail, release);</span><br><span class="line">	if (fastpath(prev)) &#123;</span><br><span class="line">	   //如果prev不等于NULL，直接在链表尾部添加节点</span><br><span class="line">		prev-&gt;do_next = head;</span><br><span class="line">	&#125;</span><br><span class="line">	//链表中之前有元素返回YES，否则返回NO</span><br><span class="line">	return (prev != NULL);</span><br><span class="line">&#125;</span><br><span class="line">//将节点放到链表开头</span><br><span class="line">void _dispatch_queue_push_slow(dispatch_queue_t dq,</span><br><span class="line">		struct dispatch_object_s *obj)</span><br><span class="line">&#123;</span><br><span class="line">	if (dx_type(dq) == DISPATCH_QUEUE_ROOT_TYPE &amp;&amp; !dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">	   //原子性的将head存储到链表头部</span><br><span class="line">		dispatch_atomic_store2o(dq, dq_items_head, obj, relaxed);</span><br><span class="line">		//唤醒global queue队列</span><br><span class="line">		return _dispatch_queue_wakeup_global(dq);</span><br><span class="line">	&#125;</span><br><span class="line">	//将obj放到链表头部并执行_dispatch_wakeup函数里的dx_probe()函数</span><br><span class="line">	_dispatch_queue_push_list_slow2(dq, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出_dispatch_queue_push分为两种情况：<br>1、如果队列的链表不为空，将节点添加到链表尾部，即dq-&gt;dq_item_tail=dc。然后队列会按先进先出(FIFO)来处理任务。<br>2、如果队列此时为空，进入到_dispatch_queue_push_slow函数。如果队列是全局队列会进入if分支，原子性的将节点添加到队列开头，并执行_dispatch_queue_wakeup_global唤醒全局队列；如果队列是主队列或自定义串行队列if分支判断不成立，执行_dispatch_queue_push_list_slow2函数，它会将节点添加到队列开头并执行<code>_dispatch_wakeup</code>函数唤醒队列。</p>
<p><code>dispatch_async</code>第一阶段的工作主要是封装外部任务并添加到队列的链表中，可以用下图来表示：<br><img src="/images/gcd/WX20180403-082846.png" alt="WX20180403-082846"></p>
<p>接着来看队列唤醒的逻辑，主要分成主队列和全局队列的唤醒和任务执行逻辑：<br>1、如果是主队列，会先调用<code>_dispatch_wakeup</code>唤醒队列，然后执行_dispatch_main_queue_wakeup函数来唤醒主线程的Runloop，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t _dispatch_wakeup(dispatch_object_t dou) &#123;</span><br><span class="line">	if (slowpath(DISPATCH_OBJECT_SUSPENDED(dou._do))) &#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//_dispatch_queue_probe判断dq_items_tail是否为空，if分支不成立</span><br><span class="line">	if (!dx_probe(dou._do)) &#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//如果dou._do-&gt;do_suspend_cnt==0，返回YES,否则返回NO；</span><br><span class="line">	//同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span><br><span class="line">	if (!dispatch_atomic_cmpxchg2o(dou._do, do_suspend_cnt, 0,</span><br><span class="line">			DISPATCH_OBJECT_SUSPEND_LOCK, release)) &#123;</span><br><span class="line">			//因为主线程do_suspend_cnt非0，所以主线程if分支判断成功</span><br><span class="line">#if DISPATCH_COCOA_COMPAT</span><br><span class="line">		if (dou._dq == &amp;_dispatch_main_q) &#123;</span><br><span class="line">			//主队列的任务执行和Runloop关联，唤醒主队列</span><br><span class="line">			return _dispatch_main_queue_wakeup();</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//放到目标队列中，重新走_dispatch_queue_push方法</span><br><span class="line">	_dispatch_retain(dou._do);</span><br><span class="line">	dispatch_queue_t tq = dou._do-&gt;do_targetq;</span><br><span class="line">	_dispatch_queue_push(tq, dou._do);</span><br><span class="line">	return tq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//唤醒主线程Runloop</span><br><span class="line">static dispatch_queue_t _dispatch_main_queue_wakeup(void) &#123;</span><br><span class="line">	dispatch_queue_t dq = &amp;_dispatch_main_q;</span><br><span class="line">	if (!dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//只初始化一次mach_port_t</span><br><span class="line">	dispatch_once_f(&amp;_dispatch_main_q_port_pred, dq,</span><br><span class="line">			_dispatch_runloop_queue_port_init);</span><br><span class="line">	_dispatch_runloop_queue_wakeup_thread(dq);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">//唤醒runloop</span><br><span class="line">static inline void _dispatch_runloop_queue_wakeup_thread(dispatch_queue_t dq) &#123;</span><br><span class="line">	mach_port_t mp = (mach_port_t)dq-&gt;do_ctxt;</span><br><span class="line">	if (!mp) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//唤醒主线程的runloop</span><br><span class="line">	kern_return_t kr = _dispatch_send_wakeup_runloop_thread(mp, 0);</span><br><span class="line">	switch (kr) &#123;</span><br><span class="line">	case MACH_SEND_TIMEOUT:</span><br><span class="line">	case MACH_SEND_TIMED_OUT:</span><br><span class="line">	case MACH_SEND_INVALID_DEST:</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		(void)dispatch_assume_zero(kr);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。用Xcode在block处打断点就会看到下图中的调用栈:</p>
<p><img src="/images/gcd/20180309162515.png" alt="20180309162515"></p>
<p>2、如果是全局队列，调用_dispatch_queue_wakeup_global函数，它封装调用了核心函数<code>_dispatch_queue_wakeup_global_slow</code>，调用栈和核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup_global_slow</span><br><span class="line">└──_dispatch_queue_wakeup_global2</span><br><span class="line">    └──_dispatch_queue_wakeup_global_slow</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n) &#123;</span><br><span class="line">	static dispatch_once_t pred;</span><br><span class="line">	dispatch_root_queue_context_t qc = dq-&gt;do_ctxt;</span><br><span class="line">	uint32_t i = n;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	_dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">	//初始化dispatch_root_queue_context_s</span><br><span class="line">	dispatch_once_f(&amp;pred, NULL, _dispatch_root_queues_init);</span><br><span class="line"></span><br><span class="line">#if DISPATCH_USE_PTHREAD_POOL</span><br><span class="line">    //为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span><br><span class="line">    //降低线程频繁创建销毁的性能消耗</span><br><span class="line">	if (fastpath(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">		while (dispatch_semaphore_signal(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">			if (!--i) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//检测线程池可用大小，如果还有，则将线程池减一</span><br><span class="line">	uint32_t j, t_count = qc-&gt;dgq_thread_pool_size;</span><br><span class="line">	do &#123;</span><br><span class="line">		if (!t_count) &#123;</span><br><span class="line">		  //线程池已达到最大使用量</span><br><span class="line">			_dispatch_root_queue_debug(&quot;pthread pool is full for root queue: &quot;</span><br><span class="line">					&quot;%p&quot;, dq);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		j = i &gt; t_count ? t_count : i;</span><br><span class="line">	&#125; while (!dispatch_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count,</span><br><span class="line">			t_count - j, &amp;t_count, relaxed));</span><br><span class="line">   //创建新的线程，入口函数是_dispatch_worker_thread</span><br><span class="line">	do &#123;</span><br><span class="line">		_dispatch_retain(dq);</span><br><span class="line">		while ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">			if (r != EAGAIN) &#123;</span><br><span class="line">				(void)dispatch_assume_zero(r);</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_temporary_resource_shortage();</span><br><span class="line">		&#125;</span><br><span class="line">		if (!attr) &#123;</span><br><span class="line">			r = pthread_detach(*pthr);</span><br><span class="line">			(void)dispatch_assume_zero(r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while (--j);</span><br><span class="line">#endif // DISPATCH_USE_PTHREAD_POOL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建新的线程后执行<code>_dispatch_worker_thread</code>函数，代码简化后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void * _dispatch_worker_thread(void *context) &#123;</span><br><span class="line">	const int64_t timeout = (pqc ? 5ull : 65ull) * NSEC_PER_SEC;</span><br><span class="line">	//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span><br><span class="line">	//降低线程频繁创建销毁的性能消耗</span><br><span class="line">	do &#123;</span><br><span class="line">	   //取出一个任务并执行</span><br><span class="line">		_dispatch_root_queue_drain(dq);</span><br><span class="line">	&#125; while (dispatch_semaphore_wait(qc-&gt;dgq_thread_mediator,</span><br><span class="line">			dispatch_time(0, timeout)) == 0);</span><br><span class="line">    //将线程池加一</span><br><span class="line">	(void)dispatch_atomic_inc2o(qc, dgq_thread_pool_size, relaxed);</span><br><span class="line">	_dispatch_queue_wakeup_global(dq);</span><br><span class="line">	_dispatch_release(dq);</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从队列取任务的入口是_dispatch_root_queue_drain函数，简化的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_root_queue_drain(dispatch_queue_t dq) &#123;</span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line">#if DISPATCH_COCOA_COMPAT</span><br><span class="line">	// ensure that high-level memory management techniques do not leak/crash</span><br><span class="line">	if (dispatch_begin_thread_4GC) &#123;</span><br><span class="line">		dispatch_begin_thread_4GC();</span><br><span class="line">	&#125;</span><br><span class="line">	//autoreleasepool的push操作</span><br><span class="line">	void *pool = _dispatch_autorelease_pool_push();</span><br><span class="line">#endif // DISPATCH_COCOA_COMPAT</span><br><span class="line"></span><br><span class="line">	_dispatch_perfmon_start();</span><br><span class="line">	struct dispatch_object_s *item;</span><br><span class="line">	//取出队列的头部节点(FIFO)</span><br><span class="line">	while ((item = fastpath(_dispatch_queue_concurrent_drain_one(dq)))) &#123;</span><br><span class="line">		//对取出的内容进行处理，核心函数</span><br><span class="line">		_dispatch_continuation_pop(item);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_perfmon_end();</span><br><span class="line"></span><br><span class="line">#if DISPATCH_COCOA_COMPAT</span><br><span class="line">    //autoreleasepool的pop操作</span><br><span class="line">	_dispatch_autorelease_pool_pop(pool);</span><br><span class="line">	if (dispatch_end_thread_4GC) &#123;</span><br><span class="line">		dispatch_end_thread_4GC();</span><br><span class="line">	&#125;</span><br><span class="line">#endif // DISPATCH_COCOA_COMPAT</span><br><span class="line"></span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列唤醒后的工作主要是用线程池(全局队列)或者唤醒Runloop(主队列)的方式从队列的链表中依次取出要执行的任务，流程图如下：<br><img src="/images/gcd/WX20180403-085535.png" alt="WX20180403-085535"></p>
<p>队列的任务取出之后就是核心的执行逻辑了，也就是<code>_dispatch_continuation_pop</code>函数的逻辑，代码和流程图如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static inline void _dispatch_continuation_pop(dispatch_object_t dou) &#123;</span><br><span class="line">	dispatch_continuation_t dc = dou._dc, dc1;</span><br><span class="line">	dispatch_group_t dg;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">	//判断传入的内容是不是队列，如果是的话执行_dispatch_queue_invoke函数，否的话就是block型的</span><br><span class="line">	//任务，直接执行block即可</span><br><span class="line">	//dispatch_barrier_async到自定义并行队列时,dou._do是用户创建的自定义queue，此时会执行</span><br><span class="line">	//_dispatch_queue_invoke，并且用信号量保证barrier的任务不会和其他任务同时执行，后续分析</span><br><span class="line">	if (DISPATCH_OBJ_IS_VTABLE(dou._do)) &#123;</span><br><span class="line">		return dx_invoke(dou._do);</span><br><span class="line">	&#125;</span><br><span class="line">	//判断是否带有DISPATCH_OBJ_ASYNC_BIT标志位</span><br><span class="line">	if ((long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;</span><br><span class="line">		dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		dc1 = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//判断是否是group</span><br><span class="line">	if ((long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">		dg = dc-&gt;dc_data;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		dg = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//dispatch_continuation_t结构体，执行dc-&gt;dc_func(dc-&gt;ctxt)</span><br><span class="line">	//本质是调用Block_layout结构体的invoke执行block的实现代码</span><br><span class="line">	_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">	if (dg) &#123;</span><br><span class="line">	   //如果是群组执行dispatch_group_leave</span><br><span class="line">		dispatch_group_leave(dg);</span><br><span class="line">		_dispatch_release(dg);</span><br><span class="line">	&#125;</span><br><span class="line">	 _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">	if (slowpath(dc1)) &#123;</span><br><span class="line">		_dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/gcd/WX20180403-090039.png" alt="WX20180403-090039"></p>
<p>总结一下：<code>dispatch_async</code>的流程是用链表保存所有提交的block，然后在底层线程池中，依次取出block并执行；而向主队列提交block则会向主线程的Runloop发送消息并唤醒Runloop，接着会在回调函数中取出block并执行。</p>
<h3 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h3><p>了解了dispatch_async的逻辑后，再来看下dispatch_sync的实现和流程。<code>dispatch_sync</code>主要封装调用了<code>dispatch_sync_f</code>函数，看一下具体代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_sync_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;</span><br><span class="line">	if (fastpath(dq-&gt;dq_width == 1)) &#123;</span><br><span class="line">	   //串行队列执行同步方法</span><br><span class="line">		return dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">	   //global queue不要求执行顺序，直接执行具体的block</span><br><span class="line">		// the global concurrent queues do not need strict ordering</span><br><span class="line">		(void)dispatch_atomic_add2o(dq, dq_running, 2, relaxed);</span><br><span class="line">		return _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	//并发队列压入同步方法</span><br><span class="line">	_dispatch_sync_f2(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出，后续逻辑主要分为两种情况：</p>
<p>1、向串行队列提交同步任务，执行dispatch_barrier_sync_f函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_barrier_sync_f(dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func) &#123;</span><br><span class="line">	if (slowpath(dq-&gt;dq_items_tail) || slowpath(DISPATCH_OBJECT_SUSPENDED(dq)))&#123;</span><br><span class="line">		return _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1, acquire))) &#123;</span><br><span class="line">		return _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		return _dispatch_barrier_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_barrier_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。<code>_dispatch_barrier_sync_f_invoke</code>代码逻辑展开后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_barrier_sync_f_invoke(dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func) &#123;</span><br><span class="line">    //任务执行核心逻辑，将当前线程的dispatch_queue_key设置为dq，然后执行block，</span><br><span class="line">    //执行完之后再恢复到之前的old_dq</span><br><span class="line">	dispatch_queue_t old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line"></span><br><span class="line">    //如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span><br><span class="line">	if (slowpath(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">		return _dispatch_barrier_sync_f2(dq);</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(dispatch_atomic_dec2o(dq, dq_running, release) == 0)) &#123;</span><br><span class="line">		_dispatch_wakeup(dq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果队列存在其他任务或者被挂起，调用<code>_dispatch_barrier_sync_f_slow</code>函数，等待该队列的任务执行完之后用信号量通知队列继续执行任务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_barrier_sync_f_slow(dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func) &#123;</span><br><span class="line">	_dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore();</span><br><span class="line">	struct dispatch_continuation_s dc = &#123;</span><br><span class="line">		.dc_data = dq,</span><br><span class="line">		.dc_func = func,</span><br><span class="line">		.dc_ctxt = ctxt,</span><br><span class="line">		.dc_other = (void*)sema,</span><br><span class="line">	&#125;;</span><br><span class="line">	struct dispatch_continuation_s dbss = &#123;</span><br><span class="line">		.do_vtable = (void *)(DISPATCH_OBJ_BARRIER_BIT |</span><br><span class="line">				DISPATCH_OBJ_SYNC_SLOW_BIT),</span><br><span class="line">		.dc_func = _dispatch_barrier_sync_f_slow_invoke,</span><br><span class="line">		.dc_ctxt = &amp;dc,</span><br><span class="line">#if DISPATCH_INTROSPECTION</span><br><span class="line">		.dc_data = (void*)_dispatch_thread_self(),</span><br><span class="line">#endif</span><br><span class="line">	&#125;;</span><br><span class="line">    //使用信号量等待其他任务执行完成</span><br><span class="line">	_dispatch_queue_push(dq, &amp;dbss);</span><br><span class="line">	_dispatch_thread_semaphore_wait(sema); // acquire</span><br><span class="line">	_dispatch_put_thread_semaphore(sema);</span><br><span class="line">    //收到signal信号，继续执行当前任务</span><br><span class="line">	if (slowpath(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		_dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		_dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、向并发队列提交同步任务，执行<code>_dispatch_sync_f2</code>函数。如果队列存在其他任务，或者队列被挂起，或者有正在执行的任务，则调用<code>_dispatch_sync_f_slow</code>函数，使用信号量等待，否则直接调用<code>_dispatch_sync_f_invoke</code>执行任务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static inline void _dispatch_sync_f2(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;</span><br><span class="line">	if (slowpath(dq-&gt;dq_items_tail) || slowpath(DISPATCH_OBJECT_SUSPENDED(dq)))&#123;</span><br><span class="line">		return _dispatch_sync_f_slow(dq, ctxt, func, false);</span><br><span class="line">	&#125;</span><br><span class="line">	uint32_t running = dispatch_atomic_add2o(dq, dq_running, 2, relaxed);</span><br><span class="line">	// re-check suspension after barrier check &lt;rdar://problem/15242126&gt;</span><br><span class="line">	if (slowpath(running &amp; 1) || slowpath(DISPATCH_OBJECT_SUSPENDED(dq))) &#123;</span><br><span class="line">		running = dispatch_atomic_sub2o(dq, dq_running, 2, relaxed);</span><br><span class="line">		return _dispatch_sync_f_slow(dq, ctxt, func, running == 0);</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		return _dispatch_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line">//队列存在其他任务|队列被挂起|有正在执行的任务，信号等待</span><br><span class="line">static void _dispatch_sync_f_slow(dispatch_queue_t dq, void *ctxt, dispatch_function_t func,</span><br><span class="line">		bool wakeup) &#123;</span><br><span class="line">	_dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore();</span><br><span class="line">	struct dispatch_continuation_s dss = &#123;</span><br><span class="line">		.do_vtable = (void*)DISPATCH_OBJ_SYNC_SLOW_BIT,</span><br><span class="line">		.dc_func = func,</span><br><span class="line">		.dc_ctxt = ctxt,</span><br><span class="line">		.dc_data = (void*)_dispatch_thread_self(),</span><br><span class="line">		.dc_other = (void*)sema,</span><br><span class="line">	&#125;;</span><br><span class="line">	_dispatch_queue_push_wakeup(dq, &amp;dss, wakeup);</span><br><span class="line">    //信号等待</span><br><span class="line">	_dispatch_thread_semaphore_wait(sema);</span><br><span class="line">	_dispatch_put_thread_semaphore(sema);</span><br><span class="line">    //信号唤醒，执行同步任务</span><br><span class="line">	if (slowpath(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		_dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		_dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(dispatch_atomic_sub2o(dq, dq_running, 2, relaxed) == 0)) &#123;</span><br><span class="line">		_dispatch_wakeup(dq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_sync</code>的逻辑主要是将任务放入队列，并用线程专属信号量做等待，保证每次只会有一个block在执行。流程图如下：</p>
<p><img src="/images/gcd/WX20180403-094052.png" alt="WX20180403-094052"></p>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><p><code>dispatch_barrier_async</code>是开发中解决多线程读写同一个资源比较好的方案，接下来看一下它的实现。<br>该函数封装调用了<code>dispatch_barrier_async_f</code>，它和dispatch_async_f类似，不同点在于vtable多了DISPATCH_OBJ_BARRIER_BIT标志位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func) &#123;</span><br><span class="line">	dispatch_continuation_t dc;</span><br><span class="line">	dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">	if (!dc) &#123;</span><br><span class="line">		return _dispatch_barrier_async_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">    //设置do_vtable的标志位，从队列中取任务时会用到</span><br><span class="line">	dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	dc-&gt;dc_func = func;</span><br><span class="line">	dc-&gt;dc_ctxt = ctxt;</span><br><span class="line"></span><br><span class="line">	_dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_barrier_async</code>如果传入的是global queue，在唤醒队列时会执行<code>_dispatch_queue_wakeup_global</code>函数，故执行效果同<code>dispatch_async</code>一致，验证了使用篇中的备注内容；<br><code>dispatch_barrier_async</code>传的queue为自定义队列时，<code>_dispatch_continuation_pop</code>参数是自定义的queue，然后在<code>_dispatch_continuation_pop</code>中执行自定义队列的dx_invoke函数，即<code>dispatch_queue_invoke</code>。它的调用栈是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_invoke</span><br><span class="line">└──_dispatch_queue_class_invoke</span><br><span class="line">    └──dispatch_queue_invoke2</span><br><span class="line">        └──_dispatch_queue_drain</span><br></pre></td></tr></table></figure>
<p>重点看一下_dispatch_queue_drain函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_thread_semaphore_t _dispatch_queue_drain(dispatch_object_t dou) &#123;</span><br><span class="line">	dispatch_queue_t dq = dou._dq, orig_tq, old_dq;</span><br><span class="line">	old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">	struct dispatch_object_s *dc, *next_dc;</span><br><span class="line">	_dispatch_thread_semaphore_t sema = 0;</span><br><span class="line">	orig_tq = dq-&gt;do_targetq;</span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line">	while (dq-&gt;dq_items_tail) &#123;</span><br><span class="line">		dc = _dispatch_queue_head(dq);</span><br><span class="line">		do &#123;</span><br><span class="line">			if (DISPATCH_OBJECT_SUSPENDED(dq)) &#123;</span><br><span class="line">			   //barrier block执行时修改了do_suspend_cnt导致此时为YES</span><br><span class="line">			   //保证barrier block执行时其他block不会同时执行</span><br><span class="line">				goto out;</span><br><span class="line">			&#125;</span><br><span class="line">			if (dq-&gt;dq_running &gt; dq-&gt;dq_width) &#123;</span><br><span class="line">				goto out;</span><br><span class="line">			&#125;</span><br><span class="line">			bool redirect = false;</span><br><span class="line">			if (!fastpath(dq-&gt;dq_width == 1)) &#123;</span><br><span class="line">				if (!DISPATCH_OBJ_IS_VTABLE(dc) &amp;&amp;</span><br><span class="line">						(long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123;</span><br><span class="line">					if (dq-&gt;dq_running &gt; 1) &#123;</span><br><span class="line">						goto out;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					redirect = true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">			if (redirect) &#123;</span><br><span class="line">				_dispatch_continuation_redirect(dq, dc);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			//barrier block之前的block已经执行完，开始执行barrier block</span><br><span class="line">			if ((sema = _dispatch_barrier_sync_f_pop(dq, dc, true))) &#123;</span><br><span class="line">				goto out;</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_continuation_pop(dc);</span><br><span class="line">			_dispatch_perfmon_workitem_inc();</span><br><span class="line">		&#125; while ((dc = next_dc));</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">	return sema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在while循环中依次取出任务并调用_dispatch_continuation_redirect函数，使得block并发执行。当遇到DISPATCH_OBJ_BARRIER_BIT标记时，会修改do_suspend_cnt标志以保证后续while循环时直接goto out。barrier block的任务执行完之后_dispatch_queue_class_invoke会将do_suspend_cnt重置回去，所以barrier block之后的任务会继续执行。</p>
<p><code>dispatch_barrier_async</code>的流程见下图：<br><img src="/images/gcd/WX20180403-102645.png" alt="WX20180403-102645"></p>
<h3 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h3><p>dispatch_async将任务添加到队列的链表中并唤醒队列，全局队列唤醒时中会从线程池里取出可用线程，如果没有则会新建线程，然后在线程中执行队列取出的任务;主队列会唤醒主线程的Runloop，然后在Runloop循环中通知GCD执行主队列提交的任务。</p>
<p>dispatch_sync一般都在当前线程执行,如果是主队列的任务还是会切换到主线程执行。它使用线程信号量来实现串行执行的功能。</p>
<p>如果我们调用dispatch_barrier_async时将Barrier blocks提交到一个global queue，barrier blocks执行效果与dispatch_async()一致；只有将Barrier blocks提交到使用DISPATCH_QUEUE_CONCURRENT属性创建的queue时它才会表现的如同预期。</p>
<p>队列的流程比较复杂，上述分析难免有遗漏或者理解不到位的地方，请指正学习。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#GCD" >
    <span class="tag-code">GCD</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/03/05/深入浅出GCD之dispatch_queue/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "cocoa-chen";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "深入浅出GCD之dispatch_queue",
        owner: "cocoa-chen",
        repo: "cocoa-chen.github.io",
        oauth: {
          client_id: "e12c4d16bb2a811822a7",
          client_secret: "8fa9d6ce27d985bc1ed6027ee666305208a5e86e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>